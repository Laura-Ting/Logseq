- 波斯特对应问题PCP(Post Corresponde Problem)
  collapsed:: true
	- 骨牌：上面有符号，下面也有符号
	- 匹配：骨牌排好序之后，上面的串和下面的串读起来是一样的
	  collapsed:: true
		- ![Replaced by Image Uploader](https://raw.githubusercontent.com/qugushihua/blog-images/master/202406051009160.png){:height 175, :width 290}
	- 构建骨牌：七个部分，相当于在M上计算
	  collapsed:: true
		- 第一部分：起始格局[ # / # q0w1w2...wn # ]
		- 第二部分：模拟读写头向右[qa/br]
			- 上面加符号是重复上一个格局，下面加符号是添加下一个格局，依据状态转移函数
		- 第三部分：模拟读写头向左[cqa/rcb]
			- 右边的改，左边的移动，所以需要3个
		- 第四部分：处理格局中不变的部分[a/a]
		- 第五部分：进入下一步计算(新的格局)[# / # ]
		- 第六部分：删除接受状态附近的符号[aqaccept/qaccept], [qaccepta/qaccept]
			- 上面长下面短
		- 第七部分：对齐最后的接受状态 [qaccept## / # ]
	- 不可判定问题，同样相当于构建ATM
	- 之前固定了P从第一个骨牌开始，对骨牌进行修正，可以将MPCP转换为PCP
	  collapsed:: true
		- 在骨牌前加一些# ，比如{[a1/b1],[ # a2/# b2],[# a3# / # b3# ]}，只有第一个不加，让他只能以第一个骨牌开始
- ### Part 4计算复杂性理论
	- 进入到图灵机后都将其统一编码为串，计算串的长度即可
	- 度量复杂性
	  collapsed:: true
		- 给定语言A={0k1k|k>=0}
		- M1="对于输入串w，（先写到带子上在做处理）
		  扫描带子，如果在1的右边发现0，就拒绝，*O(n)*
		  如果带子上既有0也有1，就重复下一步，*和扫描同时判断*
		  扫描带子，删除一个0和一个1，*一次扫描O(n)步，扫描n/2次，(n/2)O(n)=O(n2)*
		  如果所有1被删除之后还有0，或者所有0都被删除之后还有1就拒绝
		  否则，如果带子上没有剩下的0和1，就接受" *扫描O(n)步*
		  综上，*O(n)+O(n2)+O(n)*
		- 最坏情况分析：考虑在某特定长度的所有输入上的最长运行时间
		- 平均情况分析
		- 时间复杂度：令M是一个在所有输入上都停机的确定型图灵机，M的时间复杂度是一个函数f:N->N
		  collapsed:: true
			- f(n)表示M在所有长度为n的输入上运行时所经过的最大步数，f(n)是M的运行时间，M在时间f(n)内运行，M是f(n)时间图灵机，n表示输入的长度
			- 具体的运行时间：较复杂，对其进行估计
			- 渐进的运行时间：仅考虑最高次想6n3
			- 大O记法：设置f和g是函数，f，g:N->R+，若存在c，n0，任意n>=n0，f(n)<=cg(n)，则f(n)=O(g(n)),g(n)是f(n)的渐进上界
				- eg：f(n)=6n3+2n2+20n+45，g(n)=n3，令c=7，n0=7
				- 证明：当f(n)为n的多项式时，g(n)为f(n)的最高次项
				  collapsed:: true
					- 思路：f(n)=aknk+ak-1nk-1+...
					- g(n)=nk
					- 令c=|ak|+|ak-1|+...
					- cxg(n)=|ak|nk+|ak-1|nk，这样cg(n)中的每一项cg(n)>=f(n)
				- O(n2)+O(n3)=O(n3)
				  collapsed:: true
					- 设g(n)=O(n2)=>g(n)<=c1n3,n>=n1,
					  f(n)=O(n3)=>f(n)<=c2n3,n>=n2
					- g(n)+f(n)<
			- 小o记法：limf(n)/g(n)=0，f(n)=o(g(n))，g(n)是f(n)的严格渐进上界
				- eg：f(n)=根号n，g(n)=n，根号n=o(n)
				- n=o(nlog(logn))
				- nlog(logn)=o(nlogn)，洛必达法则，上下求导
				- n2=o(n3)
		- 多项式界，指数界
		- 更快判定0n1n，M2="对于输入串w，
		  扫描带子，如果在1的右边发现0，就拒绝；*O(n)步*
		  如果袋子上既有0也有1，就重复3-4步骤；*O(n)步*
		  扫描带子，检查剩余的0和1的总数是偶数还是奇数。若是奇数就拒绝。
		  再次扫描带子，从第一个0开始，隔一删除0；然后从第一个1开始，隔一删除1；00001111->0011->01，*log2n+1*
		  如果在袋子上没有剩下的0和1，就接受。”
		  综上：1.+2.*(3.+4.)=O(n)(1+log2n)+O(n)
		- 机器不同，度量出来的时间复杂度不同
		- M2的改进，M3是多带图灵机，M3=“对于输入串w，*思路，两个带子，一个带子写满0，一个带子写满1，比较这两个带子*
		  扫描带子1，如果在1的右边发现0，就拒绝；*O(n)*
		  扫描带子1上的0，知道第一个1停止，同时把0复制到带子2上；*O(n/2)*
		  扫描带子1上的1知道输入的末尾。每次从带子1上读到一个1，就从带子2上删除一个0，如果在读完1之前所有的0都被删除，就拒绝。*O(n)步*
		  如果所有的0都被删除，就接受。如果还有0剩下，就拒绝。“
		- 图灵机的时间：
		  collapsed:: true
			- M是处处停机的图灵机，函数timeM：N->N，timeM(n)="M在长度为n的输入上（最差）的运行步数"
			- 令t：N->R+是一个函数，定义时间复杂性TIME(t(n))为所有由O(t(n))时间的图灵机判定的所有语言的集合。
			- P类问题：多项式时间内可判定
		- 设t(n)是一个函数，t(n)>=n时间的多带图灵机都和某一个O(t2(n))时间的单带图灵机等价
			- 单带模拟多带：S(单带)模拟M(多带)的t(n)步操作，每步需要O(t(n))时间
			- t(n)*O(t(n))=O(t2(n))
		- 设N是一个非确定型图灵机，并且是个判定机。N运行时间是函数f：N->N，其中f(n)是在任何长度为n的输入上所有计算分支中的最大步数。
		- 设t(n)是一个函数，t(n)>=n时间的非确定型单带图灵机都与一个2O(t(n))时间的确定型单带图灵机等价。宽度优先，1+k+k*k+...=1+k+...+kt(n) kt(n)+kt(n)+kt(n)+...
		- P类：（多项式）
			- P是确定型单带图灵机在多项式时间内可判定的语言类。换言之，P=∪TIME(nk)，可解问题
			- 实例
				- 路径问题：G为有向图，图中节点s和节点t之间是否存在路径？
				  PATH={<G,s,t>|G是具有从s到t的路径的有向图}*遍历所有可能的路径x：G={V, E}，顶点|v|x|v-1|x...x1=|v|^|v|，指数级别*
				  确定性有穷自动机空性质测试，洪水标记，如果一个状态被标记但相邻状态没被标记，下一次标记，直到两次没有变化
-
-
- 时间复杂度：一个函数f(n)，N->N，输入是图灵机输入串的长度，图灵机在长度为n的串|w|上运行所需要的步数
- 长度为n的串有很多种，串不同，导致时间不同，考虑最坏情况
- 引入渐进上界，大O记法，O(g(n)) 存在c, n0, cg(n) >= f(n), n>=n0
- O(n3)+O(n2)=O(n3)
-
- 多项式类的O统称P类，P=∪TIME(nk)，与多项式时间相对应的还有指数时间，对数时间，线性时间...
- P类问题示例
	- 多项式时间内可解
	- 路径问题：G为有向图，图中的节点s和节点t是否存在路径
	  collapsed:: true
		- 遍历所有可能的路径？G=(V, E)，V={1, 2, 3}，3x2x1 |V|!=|V|x|(|V|-1)x...=|V|^|V|，最坏的情况是所有节点都选择一遍，输入的n越长，复杂度指数级别，越大
		- 指数级不是多项式时间，不是P类问题，能否找到多项式类时间解法
		- 洪水算法：M=”对输入<G, s, t>，G是包含节点s和节点t的有向图
		  1，在节点s上做标记 *O(1)*
		  2，重复步骤3，直到不再有节点被标记 *O(m)，m是最长路径的长度*
		  3，扫描G的所有边，如果找到一条边(a, b)，若a被标记而b没被标记，那么标记b *|E|*
		  4，若t被标记，则接受；否则拒绝“
		  复杂度为O(n2)=|V|x|E|
		- 如果能找到多项式时间算法则是P类问题；否则证明找不到多项式时间算法
	- 互素问题：RELPRIME={<x, y>|x与y互素}
	  collapsed:: true
		- x，y表示成二进制数，O(2^n)，2x2x2...，但是在范围[0, min(x,y)]内，遍历O(min(x, y)) 规模or长度
		- 辗转相除：E=“对输入<x, y>，x和y是二进制表示的自然数：
		  1，重复下面的操作，直到y=0
		  2，x=x mod y *每次取余后，x减小一半(一位)，当x/2 < y时，x<2y， x中最多只有1个y，x-y<y，那么x对y取余就相当于对x做一次减法*
		  3，交换x和y的值
		  4，输出x”
		  一共O(logx)次会让x变为0，每次除法的复杂度是O(n^2)，从位数角度，max(x, y)共n位，总共O(n^3)
	- 上下文无关文法的派生问题
	  collapsed:: true
		- 每一个上下文无关文法可以产生乔姆斯基方式A->BC, A->a， 2|w|-1
		- 暴力法：指数级别，如果有k条规则，把规则执行执行这些步，K^2|w|-1
		- 动态规划：多项式，用之前计算的结果推后面的结果，递推方程
		  w=‘w1, w2...wi...wj’，D[i][j][v]=D[i][k][·]&&D[k][j][·]，从i到j之间是否能有某一个规则生成，前一半子串和后一半子串检查，检查子串所有规则，若i=j则检查终结符
- NP类问题
	- 多项式时间内可验证
	- 哈密顿路径问题：有向图G中的哈密顿路径，从起点s到终点t是否存在一条经过每个顶点恰好一次的有向路径
	  collapsed:: true
		- HAMPATH={<G, s, t>|G是有向图且包含s到t的哈密顿路径}
		- 洪水算法？标记了但未必会走，无法找出路径
		- 寻找G中s的t哈密顿路径，指数时间
		- 判定G中有没有s到t的哈密顿路径？->验证机，给定候选，验证候选
		- 语言A的验证机是一个算法V，V接受<w, c>，若语言A有一个多项式时间验证机V，则称A是多项式可验证的
		  证书c能够帮助验证w属于A，给定c->验证c->s, t存在-><G, s, t>∈A
		- N1=“对输入<G, s, t>，其中G是包含顶点s和顶点p的有向图，
		  1，写下一列m个数p1，p2，...，pm(和v1,  v2...对应),m是G的顶点数，每个pi都从1到m中非确定地挑选；
		  2，检查列中是否有重复的数，若重复则拒绝，*路径问题不考虑环 O(m)*
		  3，检查是否s=p1且t=pm，若不是，则拒绝 O(2)
		  4，对于i从1到m-1，检查(pi, pi+1)是否是G中的边(路径需要是合法路径)
		  若有一个不是则拒绝 *O(m)*
		  否则所有检查都通过，接受”
		- N1是个非确定性图灵机，动态转移是非确定的
	- NP问题
	  collapsed:: true
		- 用确定性图灵机去模拟非确定性图灵机去模拟需要指数级别，验证机（多项式时间）和非确定性图灵机
		- NP问题不完全是指数时间，比指数时间可能更快一点
		- 一个语言在NP中，当且晋档他能被某个非确定性多项式时间图灵机
		- 非确定性图灵机，f(n)是在任何长度为n的输入上所有计算分支中最大步数
		- N=“对长为n的输入w；
		  非确定地选择长为n^k的字符串c；
		  在输入<w,c>上运行V；
		  若V接受，则接受；否则拒绝”
		- NTIME(t(n))={某个O(t(n))时间的非确定型图灵机判定语言L} NP=UkTIME(nk)
	- 团问题：图G中是否存在k团
		- 团：无向图中的一个子图，其中每两个节点都有边相连。包含k个节点是k团
		- CLIQUE={<G, k>|G是包含k团的无向图}
		- V=“对输入<<G, k>,c>，G为图，c为子图
		  检查c是否包含G中k个顶点 *O(k)*；
		  检查G是否包含连接c中顶点的所有边；*找候选C|v|k，从|v|中选择k个，O(k(k-1)/2)，k^2级别*
		  若两项检查都通过，则接受；否则拒绝”
- P和NP的关系：P类问题和NP问题是否相等还无法说
- NP完全性：
	- NP问题是否有相关性，某一个问题代表一类问题
	- 规约：把一个问题规约成另一个问题
	- A<=pB，针对A输入的w可以变为针对B输入的f(w)，f：∑ * -> ∑ *
		- 传递性：A<=pB且B<=pC => A<=pC
	- 若B属于NP(NP完全是NP的子集，NP性)，且NP中每个A都是多项式时间可归约到B(任意A∈NP，A<=pB，NP-hard性)，则称为NP完全的
		- 验证NP中的每个问题A，都可多项式时间规约到B
		- 若给定了一个NP完全问题B，有B<=pC，则A<=pC，C是NP完全问题
	- 什么问题是NP-hard但是却不是NP呢？满足2不满足1：图灵机的停机问题
	  collapsed:: true
		- 对于NP问题L存在一个多项式时间V能验证，构建图灵机M=“验证输入，1，枚举n^k长度C
		  2，运行V(w, c)
		  3，如果V接受，则接受
		  4，如果V拒绝，则枚举”
	- SAT既满足NP，又满足NP难
		- 验证一组赋值，是否使布尔表达式成立
-
- P类问题：多项式时间内可判定的问题n^k，以接收状态或拒绝状态停机，n是输入串的长度，k是任意常数
- NP类问题：多项式时间内的验证器V(w, c)，验证一个解是否是合理的解。当且仅当它能被某个非确定型时间图灵机判定
	- 找到路径是指数时间，验证是多项式时间，找路径用非确定的方式完成
	- 想要满足多项式时间，那么选择c也要是多项式时间的
- 概念，介绍，什么是图灵机，什么不是图灵机，什么是NP问题，什么是NP 难
- 问题和语言的对应关系，给定问题要会转换成语言，ATM={<M,w>|。。。}
- 证明，图灵机的接收问题不可判定，上下文无关文法的派生性问题（停机条件）1-3部分ppt
-