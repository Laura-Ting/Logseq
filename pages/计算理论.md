- 波斯特对应问题PCP(Post Corresponde Problem)
  collapsed:: true
	- 骨牌：上面有符号，下面也有符号
	- 匹配：骨牌排好序之后，上面的串和下面的串读起来是一样的
	  collapsed:: true
		- ![Replaced by Image Uploader](https://raw.githubusercontent.com/qugushihua/blog-images/master/202406051009160.png){:height 175, :width 290}
	- 构建骨牌：七个部分，相当于在M上计算
	  collapsed:: true
		- 第一部分：起始格局[ # / # q0w1w2...wn # ]
		- 第二部分：模拟读写头向右[qa/br]
			- 上面加符号是重复上一个格局，下面加符号是添加下一个格局，依据状态转移函数
		- 第三部分：模拟读写头向左[cqa/rcb]
			- 右边的改，左边的移动，所以需要3个
		- 第四部分：处理格局中不变的部分[a/a]
		- 第五部分：进入下一步计算(新的格局)[# / # ]
		- 第六部分：删除接受状态附近的符号[aqaccept/qaccept], [qaccepta/qaccept]
			- 上面长下面短
		- 第七部分：对齐最后的接受状态 [qaccept## / # ]
	- 不可判定问题，同样相当于构建ATM
	- 之前固定了P从第一个骨牌开始，对骨牌进行修正，可以将MPCP转换为PCP
	  collapsed:: true
		- 在骨牌前加一些# ，比如{[a1/b1],[ # a2/# b2],[# a3# / # b3# ]}，只有第一个不加，让他只能以第一个骨牌开始
- ### Part 4计算复杂性理论
	- 进入到图灵机后都将其统一编码为串，计算串的长度即可
	- 度量复杂性
		- 给定语言A={0k1k|k>=0}
		- M1="对于输入串w，（先写到袋子上在做处理）
		  扫描w，如果在1的右边发现0，就拒绝
		  如果带子上既有0也有1，就重复下一步
		  扫描带子，删除一个0和一个1
		  如果所有1被删除之后还有0，或者所有0都被删除之后还有1就拒绝
		  否则，如果带子上没有剩下的0和1，就接受"
		- 最坏情况分析：考虑在某特定长度的所有输入上的最长运行时间
		- 平均情况分析
		- 时间复杂度：令M是一个在所有输入上都停机的确定型图灵机，M的时间复杂度是一个函数f:N->N
		  collapsed:: true
			- f(n)表示M在所有长度为n的输入上运行时所经过的最大步数，f(n)是M的运行时间，M在时间f(n)内运行，M是f(n)时间图灵机，n表示输入的长度
			- 具体的运行时间：较复杂，对其进行估计
			- 渐进的运行时间：仅考虑最高次想6n3
			- 大O记法：设置f和g是函数，f，g:N->R+，若存在c，n0，任意n>=n0，f(n)<=cg(n)，则f(n)=O(g(n)),g(n)是f(n)的渐进上界
			  collapsed:: true
				- eg：f(n)=6n3+2n2+20n+45，g(n)=n3，令c=7，n0=7
				- 证明：当f(n)为n的多项式时，g(n)为f(n)的最高次项
				  collapsed:: true
					- 思路：f(n)=aknk+ak-1nk-1+...
					- g(n)=nk
					- 令c=|ak|+|ak-1|+...
					- cxg(n)=|ak|nk+|ak-1|nk，这样cg(n)中的每一项cg(n)>=f(n)
				- O(n2)+O(n3)=O(n3)
					- 设g(n)=O(n2)=>g(n)<=c1n3,n>=n1,
					  f(n)=O(n3)=>f(n)<=c2n3,n>=n2
					- g(n)+f(n)<
			- 小o记法：limf(n)/g(n)=0，f(n)=o(g(n))，g(n)是f(n)的严格渐进上界
			  collapsed:: true
				- eg：f(n)=根号n，g(n)=n，根号n=o(n)
				- n=o(nlog(logn))
				- nlog(logn)=o(nlogn)，洛必达法则，上下求导
				- n2=o(n3)
		- 多项式界，指数界
-